<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sig-api-machinery on 袁昊的学习笔记</title>
    <link>https://howieyuen.github.io/docs/kubernetes/sig-api-machinery/</link>
    <description>Recent content in sig-api-machinery on 袁昊的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 24 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://howieyuen.github.io/docs/kubernetes/sig-api-machinery/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ETCD watch 关键设计</title>
      <link>https://howieyuen.github.io/docs/kubernetes/sig-api-machinery/key-design-of-etcd-watch/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://howieyuen.github.io/docs/kubernetes/sig-api-machinery/key-design-of-etcd-watch/</guid>
      <description>注：本文转自 图解kubernetes中基于etcd的watch关键设计
 本文介绍了kubernetes针对etcd的watch场景，k8s在性能优化上面的一些设计，逐个介绍缓存、定时器、序列化缓存、bookmark机制、forget机制、针对数据的索引与ringbuffer等组件的场景以及解决的问题，希望能帮助到那些对apiserver中的watch机制实现感兴趣的朋友。
1. 事件驱动与控制器 #   k8s中并没有将业务的具体处理逻辑耦合在rest接口中，rest接口只负责数据的存储，通过控制器模式，分离数据存储与业务逻辑的耦合，保证apiserver业务逻辑的简洁。
 控制器通过watch接口来感知对应的资源的数据变更，从而根据资源对象中的期望状态与当前状态之间的差异，来决策业务逻辑的控制，watch本质上做的事情其实就是将感知到的事件发生给关注该事件的控制器。
2. Watch的核心机制 #  这里我们先介绍基于etcd实现的基础的watch模块。
2.1 事件类型与etcd #   一个数据变更本质上无非就是三种类型：新增、更新和删除，其中新增和删除都比较容易因为都可以通过当前数据获取，而更新则可能需要获取之前的数据，这里其实就是借助了etcd中revision和mvcc机制来实现，这样就可以获取到之前的状态和更新后的状态，并且获取后续的通知。
2.2 事件管道 #   事件管道则是负责事件的传递，在watch的实现中通过两级管道来实现消息的分发，首先通过watch etcd中的key获取感兴趣的事件，并进行数据的解析，完成从bytes到内部事件的转换并且发送到输入管道(incomingEventChan)中，然后后台会有线程负责输入管道中获取数据，并进行解析发送到输出管道(resultChan)中，后续会从该管道来进行事件的读取发送给对应的客户端。
2.3 事件缓冲区 #  事件缓冲区是指的如果对应的事件处理程序与当前事件发生的速率不匹配的时候，则需要一定的buffer来暂存因为速率不匹配的事件， 在go里面大家通常使用一个有缓冲的channel构建。
 到这里基本上就实现了一个基本可用的watch服务，通过etcd的watch接口监听数据，然后启动独立goroutine来进行事件的消费，并且发送到事件管道供其他接口调用。
3. Cacher #  kubernetes中所有的数据和系统都基于etcd来实现，如何减轻访问压力呢，答案就是缓存，watch也是这样，本节我们来看看如何实现watch缓存机制的实现，这里的cacher是针对
3.1 Reflector #   Reflector是client-go中的一个组件，其通过listwatch接口获取数据存储在自己内部的store中，cacher中通过该组件对etcd进行watch操作，避免为每个组件都创建一个etcd的watcher。
3.2 watchCache #   wacthCache负责存储watch到的事件，并且将watch的事件建立对应的本地索引缓存，同时在构建watchCache还负责将事件的传递，其将watch到的事件通过eventHandler来传递给上层的Cacher组件。
3.3 cacheWatcher #   cacheWatcher顾名思义其是就是针对cache的一个watcher(watch.Interface)实现， 前端的watchServer负责从ResultChan里面获取事件进行转发。
3.4 Cacher #   Cacher基于etcd的store结合上面的watchCache和Reflector共同构建带缓存的REST store， 针对普通的增删改功能其直接转发给etcd的store来进行底层的操作，而对于watch操作则进行拦截，构建并返回cacheWatcher组件。</description>
    </item>
    
  </channel>
</rss>
