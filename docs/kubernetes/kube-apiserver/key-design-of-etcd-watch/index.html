<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="注：本文转自 图解 kubernetes 中基于 etcd 的 watch 关键设计
本文介绍了 kubernetes 针对 etcd 的 watch 场景，k8s 在性能优化上面的一些设计， 逐个介绍缓存、定时器、序列化缓存、bookmark 机制、forget 机制、 针对数据的索引与 ringbuffer 等组件的场景以及解决的问题， 希望能帮助到那些对 apiserver 中的 watch 机制实现感兴趣的朋友。
1. 事件驱动与控制器 # k8s 中并没有将业务的具体处理逻辑耦合在 rest 接口中，rest 接口只负责数据的存储， 通过控制器模式，分离数据存储与业务逻辑的耦合，保证 apiserver 业务逻辑的简洁。
控制器通过 watch 接口来感知对应的资源的数据变更，从而根据资源对象中的期望状态与当前状态之间的差异， 来决策业务逻辑的控制，watch 本质上做的事情其实就是将感知到的事件发生给关注该事件的控制器。
2. Watch 的核心机制 # 这里我们先介绍基于 etcd 实现的基础的 watch 模块。
2.1 事件类型与 etcd # 一个数据变更本质上无非就是三种类型：新增、更新和删除， 其中新增和删除都比较容易因为都可以通过当前数据获取，而更新则可能需要获取之前的数据， 这里其实就是借助了 etcd 中 revision 和 mvcc 机制来实现，这样就可以获取到之前的状态和更新后的状态， 并且获取后续的通知。
2.2 事件管道 # 事件管道则是负责事件的传递，在 watch 的实现中通过两级管道来实现消息的分发， 首先通过 watch etcd 中的 key 获取感兴趣的事件，并进行数据的解析， 完成从 bytes 到内部事件的转换并且发送到输入管道 (incomingEventChan) 中， 然后后台会有线程负责输入管道中获取数据，并进行解析发送到输出管道 (resultChan) 中， 后续会从该管道来进行事件的读取发送给对应的客户端。">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="watch 关键设计" />
<meta property="og:description" content="注：本文转自 图解 kubernetes 中基于 etcd 的 watch 关键设计
本文介绍了 kubernetes 针对 etcd 的 watch 场景，k8s 在性能优化上面的一些设计， 逐个介绍缓存、定时器、序列化缓存、bookmark 机制、forget 机制、 针对数据的索引与 ringbuffer 等组件的场景以及解决的问题， 希望能帮助到那些对 apiserver 中的 watch 机制实现感兴趣的朋友。
1. 事件驱动与控制器 # k8s 中并没有将业务的具体处理逻辑耦合在 rest 接口中，rest 接口只负责数据的存储， 通过控制器模式，分离数据存储与业务逻辑的耦合，保证 apiserver 业务逻辑的简洁。
控制器通过 watch 接口来感知对应的资源的数据变更，从而根据资源对象中的期望状态与当前状态之间的差异， 来决策业务逻辑的控制，watch 本质上做的事情其实就是将感知到的事件发生给关注该事件的控制器。
2. Watch 的核心机制 # 这里我们先介绍基于 etcd 实现的基础的 watch 模块。
2.1 事件类型与 etcd # 一个数据变更本质上无非就是三种类型：新增、更新和删除， 其中新增和删除都比较容易因为都可以通过当前数据获取，而更新则可能需要获取之前的数据， 这里其实就是借助了 etcd 中 revision 和 mvcc 机制来实现，这样就可以获取到之前的状态和更新后的状态， 并且获取后续的通知。
2.2 事件管道 # 事件管道则是负责事件的传递，在 watch 的实现中通过两级管道来实现消息的分发， 首先通过 watch etcd 中的 key 获取感兴趣的事件，并进行数据的解析， 完成从 bytes 到内部事件的转换并且发送到输入管道 (incomingEventChan) 中， 然后后台会有线程负责输入管道中获取数据，并进行解析发送到输出管道 (resultChan) 中， 后续会从该管道来进行事件的读取发送给对应的客户端。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://howieyuen.github.io/docs/kubernetes/kube-apiserver/key-design-of-etcd-watch/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2020-09-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-09-29T16:11:47+08:00" />

<title>watch 关键设计 | 袁昊的学习笔记</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css" integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.814a49be84d14a844e6e7e4ba106fffd2a377994439df71572388d60b06575f0.js" integrity="sha256-gUpJvoTRSoRObn5LoQb//So3eZRDnfcVcjiNYLBldfA=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.jpeg" alt="Logo" /><span>袁昊的学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>Golang</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-aa0ad5dadefefc3354befb0f21b44571" class="toggle"  />
    <label for="section-aa0ad5dadefefc3354befb0f21b44571" class="flex justify-between">
      <a role="button" class="">数据结构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/data-structure/chan/" class="">chan</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/data-structure/map/" class="">map</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/data-structure/slice/" class="">slice</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9730b84098027970ce9876389c401abb" class="toggle"  />
    <label for="section-9730b84098027970ce9876389c401abb" class="flex justify-between">
      <a role="button" class="">语言基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/language-basics/unsafe/" class="">unsafe</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/language-basics/reflect/" class="">reflect</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-84d526a58cfe5a50fb73329d6c7bd14a" class="toggle"  />
    <label for="section-84d526a58cfe5a50fb73329d6c7bd14a" class="flex justify-between">
      <a role="button" class="">内存管理</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/memory-manage/memory-model/" class="">内存模型</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-084099e607ed94fee6028accac1c176c" class="toggle"  />
    <label for="section-084099e607ed94fee6028accac1c176c" class="flex justify-between">
      <a role="button" class="">golang 工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/tools/pprof/" class="">pprof</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Kubernetes</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-103a3040e6af1931bd7a973aa3d5fe12" class="toggle" checked />
    <label for="section-103a3040e6af1931bd7a973aa3d5fe12" class="flex justify-between">
      <a role="button" class="">kube-apisever</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-apiserver/authorization/" class="">鉴权机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-apiserver/authentication/" class="">认证机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-apiserver/garbage-collector/" class="">垃圾回收</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-apiserver/key-design-of-etcd-watch/" class="active">watch 关键设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-apiserver/crd/" class="">CRD 入门和使用</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-55afec95d17025ab2841fd395bf5e066" class="toggle"  />
    <label for="section-55afec95d17025ab2841fd395bf5e066" class="flex justify-between">
      <a role="button" class="">kube-controller-manager</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-controller-manager/code-analysis-of-garbagecollector-controller/" class="">GC Controller 源码分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-controller-manager/code-analysis-of-daemonset-controller/" class="">DaemonSet Controller 源码分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-controller-manager/code-analysis-of-statefulset-controller/" class="">Statefulset Controller 源码分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-controller-manager/k8s-apps-rolling-update/" class="">无状态应用滚动更新</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6c06d491bb5aface6ab2585a8049b13f" class="toggle"  />
    <label for="section-6c06d491bb5aface6ab2585a8049b13f" class="flex justify-between">
      <a role="button" class="">kube-scheduler</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kube-scheduler/advanced-scheduling/" class="">高级调度</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-89eea73f7e04e77c22ade24239d6a83e" class="toggle"  />
    <label for="section-89eea73f7e04e77c22ade24239d6a83e" class="flex justify-between">
      <a role="button" class="">kubelet</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kubelet/kubelet-topology-manager/" class="">Topology Manager 设计方案</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/kubelet/kubelet-eviction-manager/" class="">Eviction Manager 工作机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f0e31a9428c0c5fa066c9ad36b1ae0b6" class="toggle"  />
    <label for="section-f0e31a9428c0c5fa066c9ad36b1ae0b6" class="flex justify-between">
      <a role="button" class="">sig-network</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/kubernetes/sig-network/learn-about-Service/" class="">深入了解 Service</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Translation</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f59f78b27df0d3218be457339234a283" class="toggle"  />
    <label for="section-f59f78b27df0d3218be457339234a283" class="flex justify-between">
      <a role="button" class="">Protocol Buffers</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/translation/protobuf/overview-of-protocal-buffers/" class="">概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/translation/protobuf/language-guideproto3/" class="">语言指南（proto3）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f44f2048d84a295b965240d95f5edc80" class="toggle"  />
    <label for="section-f44f2048d84a295b965240d95f5edc80" class="flex justify-between">
      <a role="button" class="">X as Code</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/translation/XaC/how-to-manage-gitops-secrets-a-detailed-guide/" class="">如何管理 GitOps Secret：详细指南</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-20038bcc21ca3d914920842c4a32533d" class="toggle"  />
    <label for="section-20038bcc21ca3d914920842c4a32533d" class="flex justify-between">
      <a role="button" class="">LeetCode</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/leetcode/0321/" class="">321. 拼接最大数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/leetcode/0416/" class="">416. 分割等和子集</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/" >
        Blogs
      </a>
  </li>
  
  <li>
    <a href="https://github.com/howieyuen/" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>watch 关键设计</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#1-事件驱动与控制器">1. 事件驱动与控制器</a></li>
    <li><a href="#2-watch-的核心机制">2. Watch 的核心机制</a>
      <ul>
        <li><a href="#21-事件类型与-etcd">2.1 事件类型与 etcd</a></li>
        <li><a href="#22-事件管道">2.2 事件管道</a></li>
        <li><a href="#23-事件缓冲区">2.3 事件缓冲区</a></li>
      </ul>
    </li>
    <li><a href="#3-cacher">3. Cacher</a>
      <ul>
        <li><a href="#31-reflector">3.1 Reflector</a></li>
        <li><a href="#32-watchcache">3.2 watchCache</a></li>
        <li><a href="#33-cachewatcher">3.3 cacheWatcher</a></li>
        <li><a href="#34-cacher">3.4 Cacher</a></li>
      </ul>
    </li>
    <li><a href="#4-cacher-的优化">4. Cacher 的优化</a>
      <ul>
        <li><a href="#41-序列化缓存">4.1 序列化缓存</a></li>
        <li><a href="#42-nonblocking">4.2 nonblocking</a></li>
        <li><a href="#43-timebudget">4.3 TimeBudget</a></li>
        <li><a href="#44-forget-机制">4.4 forget 机制</a></li>
        <li><a href="#45-bookmark-机制">4.5 bookmark 机制</a></li>
        <li><a href="#46-watchcache-中的-ringbuffer">4.6 watchCache 中的 ringbuffer</a></li>
      </ul>
    </li>
    <li><a href="#5-设计总结">5. 设计总结</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><blockquote>
<p>注：本文转自 
  <a href="https://www.kubernetes.org.cn/6889.html">图解 kubernetes 中基于 etcd 的 watch 关键设计</a></p>
</blockquote>
<p>本文介绍了 kubernetes 针对 etcd 的 watch 场景，k8s 在性能优化上面的一些设计，
逐个介绍缓存、定时器、序列化缓存、bookmark 机制、forget 机制、
针对数据的索引与 ringbuffer 等组件的场景以及解决的问题，
希望能帮助到那些对 apiserver 中的 watch 机制实现感兴趣的朋友。</p>
<h1 id="1-事件驱动与控制器">
  1. 事件驱动与控制器
  <a class="anchor" href="#1-%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e4%b8%8e%e6%8e%a7%e5%88%b6%e5%99%a8">#</a>
</h1>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image1.png" alt="image1" /></p>
<p>k8s 中并没有将业务的具体处理逻辑耦合在 rest 接口中，rest 接口只负责数据的存储，
通过控制器模式，分离数据存储与业务逻辑的耦合，保证 apiserver 业务逻辑的简洁。</p>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image2.png" alt="image2" /></p>
<p>控制器通过 watch 接口来感知对应的资源的数据变更，从而根据资源对象中的期望状态与当前状态之间的差异，
来决策业务逻辑的控制，watch 本质上做的事情其实就是将感知到的事件发生给关注该事件的控制器。</p>
<h1 id="2-watch-的核心机制">
  2. Watch 的核心机制
  <a class="anchor" href="#2-watch-%e7%9a%84%e6%a0%b8%e5%bf%83%e6%9c%ba%e5%88%b6">#</a>
</h1>
<p>这里我们先介绍基于 etcd 实现的基础的 watch 模块。</p>
<h2 id="21-事件类型与-etcd">
  2.1 事件类型与 etcd
  <a class="anchor" href="#21-%e4%ba%8b%e4%bb%b6%e7%b1%bb%e5%9e%8b%e4%b8%8e-etcd">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image3.png" alt="image3" /></p>
<p>一个数据变更本质上无非就是三种类型：新增、更新和删除，
其中新增和删除都比较容易因为都可以通过当前数据获取，而更新则可能需要获取之前的数据，
这里其实就是借助了 etcd 中 revision 和 mvcc 机制来实现，这样就可以获取到之前的状态和更新后的状态，
并且获取后续的通知。</p>
<h2 id="22-事件管道">
  2.2 事件管道
  <a class="anchor" href="#22-%e4%ba%8b%e4%bb%b6%e7%ae%a1%e9%81%93">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image4.png" alt="image4" /></p>
<p>事件管道则是负责事件的传递，在 watch 的实现中通过两级管道来实现消息的分发，
首先通过 watch etcd 中的 key 获取感兴趣的事件，并进行数据的解析，
完成从 bytes 到内部事件的转换并且发送到输入管道 (incomingEventChan) 中，
然后后台会有线程负责输入管道中获取数据，并进行解析发送到输出管道 (resultChan) 中，
后续会从该管道来进行事件的读取发送给对应的客户端。</p>
<h2 id="23-事件缓冲区">
  2.3 事件缓冲区
  <a class="anchor" href="#23-%e4%ba%8b%e4%bb%b6%e7%bc%93%e5%86%b2%e5%8c%ba">#</a>
</h2>
<p>事件缓冲区是指的如果对应的事件处理程序与当前事件发生的速率不匹配的时候，
则需要一定的 buffer 来暂存因为速率不匹配的事件，
在 go 里面大家通常使用一个有缓冲的 channel 构建。</p>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image5.png" alt="image5" /></p>
<p>到这里基本上就实现了一个基本可用的 watch 服务，通过 etcd 的 watch 接口监听数据，
然后启动独立 goroutine 来进行事件的消费，并且发送到事件管道供其他接口调用。</p>
<h1 id="3-cacher">
  3. Cacher
  <a class="anchor" href="#3-cacher">#</a>
</h1>
<p>kubernetes 中所有的数据和系统都基于 etcd 来实现，如何减轻访问压力呢，
答案就是缓存，watch 也是这样，本节我们来看看如何实现 watch 缓存机制的实现，
这里的 cacher 是针对 watch 的。</p>
<h2 id="31-reflector">
  3.1 Reflector
  <a class="anchor" href="#31-reflector">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image6.png" alt="image6" /></p>
<p>Reflector 是 client-go 中的一个组件，其通过 listwatch 接口获取数据存储在自己内部的 store 中，
cacher 中通过该组件对 etcd 进行 watch 操作，避免为每个组件都创建一个 etcd 的 watcher。</p>
<h2 id="32-watchcache">
  3.2 watchCache
  <a class="anchor" href="#32-watchcache">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image7.png" alt="image7" /></p>
<p>watchCache 负责存储 watch 到的事件，并且将 watch 的事件建立对应的本地索引缓存，
同时在构建 watchCache 还负责将事件的传递，
其将 watch 到的事件通过 eventHandler 来传递给上层的 Cacher 组件。</p>
<h2 id="33-cachewatcher">
  3.3 cacheWatcher
  <a class="anchor" href="#33-cachewatcher">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image8.png" alt="image8" /></p>
<p>cacheWatcher 顾名思义其是就是针对 cache 的一个 watcher(watch.Interface) 实现，
前端的 watchServer 负责从 ResultChan 里面获取事件进行转发。</p>
<h2 id="34-cacher">
  3.4 Cacher
  <a class="anchor" href="#34-cacher">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image9.png" alt="image9" /></p>
<p>Cacher 基于 etcd 的 store 结合上面的 watchCache 和 Reflector 共同构建带缓存的 REST store，
针对普通的增删改功能其直接转发给 etcd 的 store 来进行底层的操作，而对于 watch 操作则进行拦截，
构建并返回 cacheWatcher 组件。</p>
<h1 id="4-cacher-的优化">
  4. Cacher 的优化
  <a class="anchor" href="#4-cacher-%e7%9a%84%e4%bc%98%e5%8c%96">#</a>
</h1>
<p>看完基础组件的实现，接着我们看下针对 watch 这个场景 k8s 中还做了那些优化，学习针对类似场景的优化方案。</p>
<h2 id="41-序列化缓存">
  4.1 序列化缓存
  <a class="anchor" href="#41-%e5%ba%8f%e5%88%97%e5%8c%96%e7%bc%93%e5%ad%98">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image10.png" alt="image10" /></p>
<p>如果我们有多个 watcher 都 watch 同一个事件，在最终的时候我们都需要进行序列化，
cacher 中在分发的时候，如果发现超过指定数量的 watcher， 则会在进行 dispatch 的时候，
为其构建构建一个缓存函数，针对多个 watcher 只会进行一次的序列化。</p>
<h2 id="42-nonblocking">
  4.2 nonblocking
  <a class="anchor" href="#42-nonblocking">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image11.png" alt="image11" /></p>
<p>在上面我们提到过事件缓冲区，但是如果某个 watcher 消费过慢依然会影响事件的分发，
为此 cacher 中通过是否阻塞（是否可以直接将数据写入到管道中）来将 watcher 分为两类，
针对不能立即投递事件的 watcher， 则会在后续进行重试。</p>
<h2 id="43-timebudget">
  4.3 TimeBudget
  <a class="anchor" href="#43-timebudget">#</a>
</h2>
<p>针对阻塞的 watcher 在进行重试的时候，会通过 dispatchTimeoutBudget 构建一个定时器来进行超时控制，
那什么叫 Budget 呢，其实如果在这段时间内，如果重试立马就成功，则本次剩余的时间，
在下一次进行定时的时候，则可以使用之前剩余的余额，但是后台也还有个线程，用于周期性重置。</p>
<h2 id="44-forget-机制">
  4.4 forget 机制
  <a class="anchor" href="#44-forget-%e6%9c%ba%e5%88%b6">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image12.png" alt="image12" /></p>
<p>针对上面的 TimeBudget 如果在给定的时间内依旧无法进行重试成功，
则就会通过 forget 来删除对应的 watcher，
由此针对消费特别缓慢的 watcher 则可以通过后续的重试来重新建立 watch，
从而减小对 a piserver 的 watch 压力。</p>
<h2 id="45-bookmark-机制">
  4.5 bookmark 机制
  <a class="anchor" href="#45-bookmark-%e6%9c%ba%e5%88%b6">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image13.png" alt="image13" /></p>
<p>bookmark 机制是大阿里提供的一种优化方案，其核心是为了避免单个某个资源一直没有对应的事件，
此时对应的 informer 的 revision 会落后集群很大，
bookmark 通过构建一种 BookMark 类型的事件来进行 revision 的传递，
从而让 informer 在重启后不至于落后特别多。</p>
<h2 id="46-watchcache-中的-ringbuffer">
  4.6 watchCache 中的 ringbuffer
  <a class="anchor" href="#46-watchcache-%e4%b8%ad%e7%9a%84-ringbuffer">#</a>
</h2>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image14.png" alt="image14" /></p>
<p>watchCache 中通过 store 来构建了对应的索引缓存，但是在 listwatch 操作的时候，
则通常需要获取某个 revision 后的所有数据，
针对这类数据 watchCache 中则构建了一个 ringbuffer 来进行历史数据的缓存。</p>
<h1 id="5-设计总结">
  5. 设计总结
  <a class="anchor" href="#5-%e8%ae%be%e8%ae%a1%e6%80%bb%e7%bb%93">#</a>
</h1>
<p>
  <img src="/kubernetes/kube-apiserver/watch/image15.png" alt="image15" /></p>
<p>本文介绍了 kubernetes 针对 etcd 的 watch 场景，k8s 在性能优化上面的一些设计，
逐个介绍缓存、定时器、序列化缓存、bookmark 机制、forget 机制、
针对数据的索引与 ringbuffer 等组件的场景以及解决的问题，
希望能帮助到那些对 apiserver 中的 watch 机制实现感兴趣的朋友。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/howieyuen/howieyuen.github.io/commit/1535ad5d940570eeed948be0098d8fc362e69564" title='Last modified by howieyuen | September 29, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>September 29, 2022</span>
    </a>
  </div>




</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#1-事件驱动与控制器">1. 事件驱动与控制器</a></li>
    <li><a href="#2-watch-的核心机制">2. Watch 的核心机制</a>
      <ul>
        <li><a href="#21-事件类型与-etcd">2.1 事件类型与 etcd</a></li>
        <li><a href="#22-事件管道">2.2 事件管道</a></li>
        <li><a href="#23-事件缓冲区">2.3 事件缓冲区</a></li>
      </ul>
    </li>
    <li><a href="#3-cacher">3. Cacher</a>
      <ul>
        <li><a href="#31-reflector">3.1 Reflector</a></li>
        <li><a href="#32-watchcache">3.2 watchCache</a></li>
        <li><a href="#33-cachewatcher">3.3 cacheWatcher</a></li>
        <li><a href="#34-cacher">3.4 Cacher</a></li>
      </ul>
    </li>
    <li><a href="#4-cacher-的优化">4. Cacher 的优化</a>
      <ul>
        <li><a href="#41-序列化缓存">4.1 序列化缓存</a></li>
        <li><a href="#42-nonblocking">4.2 nonblocking</a></li>
        <li><a href="#43-timebudget">4.3 TimeBudget</a></li>
        <li><a href="#44-forget-机制">4.4 forget 机制</a></li>
        <li><a href="#45-bookmark-机制">4.5 bookmark 机制</a></li>
        <li><a href="#46-watchcache-中的-ringbuffer">4.6 watchCache 中的 ringbuffer</a></li>
      </ul>
    </li>
    <li><a href="#5-设计总结">5. 设计总结</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












