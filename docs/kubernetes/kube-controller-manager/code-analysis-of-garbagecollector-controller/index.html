<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1. 序言 #  垃圾回收相关，可参考 这里
2. 源码解析 #  GarbageCollectorController 负责回收集群中的资源对象，要做到这一点，首先得监控所有资源。gc controller 会监听集群中所有可删除资源的事件，这些事件会放到一个队列中，然后启动多个 worker 协程处理。对于删除事件，则根据删除策略删除对象；其他事件，更新对象之间的依赖关系。
2.1 startGarbageCollectorController() #  首先来看 gc controller 的入口方法，也就是 kube-controller-manager 是如何启动它的。它的主要逻辑：
 判断是否启用 gc controller，默认是 true 初始化 clientset，使用 discoveryClient 获取集群中所有资源 注册不考虑 gc 的资源，默认为空 调用 garbagecollector.NewGarbageCollector() 方法 初始化 gc controller 对象 调用 garbageCollector.Run() 启动 gc controller，workers 默认是 20 调用 garbageCollector.Sync() 监听集群中的资源，当出现新的资源时，同步到 minitors 中 调用 garbagecollector.NewDebugHandler() 注册 debug 接口，用来提供集群内所有对象的关联关系；  cmd/kube-controller-manager/app/core.go:538
func startGarbageCollectorController(ctx ControllerContext) (http.Handler, bool, error) { // 1.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="GC Controller 源码分析" />
<meta property="og:description" content="1. 序言 #  垃圾回收相关，可参考 这里
2. 源码解析 #  GarbageCollectorController 负责回收集群中的资源对象，要做到这一点，首先得监控所有资源。gc controller 会监听集群中所有可删除资源的事件，这些事件会放到一个队列中，然后启动多个 worker 协程处理。对于删除事件，则根据删除策略删除对象；其他事件，更新对象之间的依赖关系。
2.1 startGarbageCollectorController() #  首先来看 gc controller 的入口方法，也就是 kube-controller-manager 是如何启动它的。它的主要逻辑：
 判断是否启用 gc controller，默认是 true 初始化 clientset，使用 discoveryClient 获取集群中所有资源 注册不考虑 gc 的资源，默认为空 调用 garbagecollector.NewGarbageCollector() 方法 初始化 gc controller 对象 调用 garbageCollector.Run() 启动 gc controller，workers 默认是 20 调用 garbageCollector.Sync() 监听集群中的资源，当出现新的资源时，同步到 minitors 中 调用 garbagecollector.NewDebugHandler() 注册 debug 接口，用来提供集群内所有对象的关联关系；  cmd/kube-controller-manager/app/core.go:538
func startGarbageCollectorController(ctx ControllerContext) (http.Handler, bool, error) { // 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://howieyuen.github.io/docs/kubernetes/kube-controller-manager/code-analysis-of-garbagecollector-controller/" />
<meta property="article:published_time" content="2020-10-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-06T18:22:21+08:00" />
<title>GC Controller 源码分析 | 袁昊的学习笔记</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.b77585324406fdba98b0d6281e32068303e5690a92ea506b5d2c6032cc22f6d5.css" integrity="sha256-t3WFMkQG/bqYsNYoHjIGgwPlaQqS6lBrXSxgMswi9tU=">
<script defer src="/en.search.min.40838ce8e186d262502fed0ac4a6bd0ad9e57f1a34c03472be973246f5e384ef.js" integrity="sha256-QIOM6OGG0mJQL&#43;0KxKa9Ctnlfxo0wDRyvpcyRvXjhO8="></script>

<script defer src="/sw.min.74a8bb07f0bee86d6bb9a2750f073f14d93c7e4512f28860370cfd879e9719b4.js" integrity="sha256-dKi7B/C&#43;6G1ruaJ1Dwc/FNk8fkUS8ohgNwz9h56XGbQ="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><img src="/logo.jpeg" alt="Logo" /><span>袁昊的学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Golang</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>数据结构</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/golang/data-structure/chan/" class="">chan</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/golang/data-structure/map/" class="">map</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/golang/data-structure/slice/" class="">slice</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>语言基础</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/golang/language-basics/unsafe/" class="">unsafe</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/golang/language-basics/reflect/" class="">reflect</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>内存管理</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/golang/memory-manage/memory-model/" class="">内存模型</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Kubernetes</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>kube-apisever</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-apiserver/authorization/" class="">鉴权机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-apiserver/authentication/" class="">认证机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-apiserver/garbage-collector/" class="">垃圾回收</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-apiserver/key-design-of-etcd-watch/" class="">watch 关键设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-apiserver/crd/" class="">CRD 入门和使用</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>kube-controller-manager</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-controller-manager/code-analysis-of-garbagecollector-controller/" class=" active">GC Controller 源码分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-controller-manager/code-analysis-of-daemonset-controller/" class="">DaemonSet Controller 源码分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-controller-manager/code-analysis-of-statefulset-controller/" class="">Statefulset Controller 源码分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-controller-manager/k8s-apps-rolling-update/" class="">无状态应用滚动更新</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>kube-scheduler</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kube-scheduler/advanced-scheduling/" class="">高级调度</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>kubelet</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kubelet/kubelet-topology-manager/" class="">Topology Manager 设计方案</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/kubelet/kubelet-eviction-manager/" class="">Eviction Manager 工作机制</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>sig-network</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/kubernetes/sig-network/learn-about-Service/" class="">深入了解 Service</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-20038bcc21ca3d914920842c4a32533d" class="toggle"  />
    <label for="section-20038bcc21ca3d914920842c4a32533d" class="flex justify-between">
      <a  class="">LeetCode</a>
      <span>▾</span>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/leetcode/0321/" class="">321. 拼接最大数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://howieyuen.github.io/docs/leetcode/0416/" class="">416. 分割等和子集</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/howieyuen/" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://themes.gohugo.io/hugo-book/" target="_blank" rel="noopener">
        Hugo Themes
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>GC Controller 源码分析</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav id="TableOfContents">
  <ul>
    <li><a href="#1-序言">1. 序言</a></li>
    <li><a href="#2-源码解析">2. 源码解析</a>
      <ul>
        <li><a href="#21-startgarbagecollectorcontroller">2.1 startGarbageCollectorController()</a>
          <ul>
            <li><a href="#211-garbagecollectorrun">2.1.1 garbageCollector.Run()</a></li>
            <li><a href="#212-gcrunattempttodeleteworker">2.1.2 gc.runAttemptToDeleteWorker()</a></li>
            <li><a href="#213-gcrunattempttoorphanworker">2.1.3 gc.runAttemptToOrphanWorker()</a></li>
            <li><a href="#214-小结">2.1.4 小结</a></li>
          </ul>
        </li>
        <li><a href="#22-garbagecollectorsync">2.2 garbageCollector.Sync()</a>
          <ul>
            <li><a href="#221-getdeletableresources">2.2.1 GetDeletableResources()</a></li>
            <li><a href="#222-gcresyncmonitors">2.2.2 gc.resyncMonitors()</a></li>
          </ul>
        </li>
        <li><a href="#23-garbagecollectornewdebughandler">2.3 garbagecollector.NewDebugHandler()</a></li>
        <li><a href="#24-总结">2.4 总结</a></li>
      </ul>
    </li>
    <li><a href="#3-参考资料">3. 参考资料</a></li>
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="1-序言">
  1. 序言
  <a class="anchor" href="#1-%e5%ba%8f%e8%a8%80">#</a>
</h1>
<p>垃圾回收相关，可参考 
  <a href="/docs/kubernetes/kube-apiserver/garbage-collector/">这里</a></p>
<h1 id="2-源码解析">
  2. 源码解析
  <a class="anchor" href="#2-%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90">#</a>
</h1>
<p>GarbageCollectorController 负责回收集群中的资源对象，要做到这一点，首先得监控所有资源。gc controller 会监听集群中所有可删除资源的事件，这些事件会放到一个队列中，然后启动多个 worker 协程处理。对于删除事件，则根据删除策略删除对象；其他事件，更新对象之间的依赖关系。</p>
<h2 id="21-startgarbagecollectorcontroller">
  2.1 startGarbageCollectorController()
  <a class="anchor" href="#21-startgarbagecollectorcontroller">#</a>
</h2>
<p>首先来看 gc controller 的入口方法，也就是 kube-controller-manager 是如何启动它的。它的主要逻辑：</p>
<ol>
<li>判断是否启用 gc controller，默认是 true</li>
<li>初始化 clientset，使用 discoveryClient 获取集群中所有资源</li>
<li>注册不考虑 gc 的资源，默认为空</li>
<li>调用 <code>garbagecollector.NewGarbageCollector()</code> 方法 初始化 gc controller 对象</li>
<li>调用 <code>garbageCollector.Run()</code> 启动 gc controller，workers 默认是 20</li>
<li>调用 <code>garbageCollector.Sync()</code> 监听集群中的资源，当出现新的资源时，同步到 minitors 中</li>
<li>调用 <code>garbagecollector.NewDebugHandler()</code> 注册 debug 接口，用来提供集群内所有对象的关联关系；</li>
</ol>
<p><code>cmd/kube-controller-manager/app/core.go:538</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">startGarbageCollectorController</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">ControllerContext</span>) (<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Handler</span>, <span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#75715e">// 1. 判断是否启用 gc controller，默认是 true
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">GarbageCollectorController</span>.<span style="color:#a6e22e">EnableGarbageCollector</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#75715e">// 2. 初始化 clientset
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gcClientset</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">ClientBuilder</span>.<span style="color:#a6e22e">ClientOrDie</span>(<span style="color:#e6db74">&#34;generic-garbage-collector&#34;</span>)

	<span style="color:#a6e22e">config</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">ClientBuilder</span>.<span style="color:#a6e22e">ConfigOrDie</span>(<span style="color:#e6db74">&#34;generic-garbage-collector&#34;</span>)
	<span style="color:#a6e22e">metadataClient</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">metadata</span>.<span style="color:#a6e22e">NewForConfig</span>(<span style="color:#a6e22e">config</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#75715e">// 3. 注册不考虑 gc 的资源，默认为空
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ignoredResources</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupResource</span>]<span style="color:#66d9ef">struct</span>{})
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">GarbageCollectorController</span>.<span style="color:#a6e22e">GCIgnoredResources</span> {
		<span style="color:#a6e22e">ignoredResources</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupResource</span>{<span style="color:#a6e22e">Group</span>: <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Group</span>, <span style="color:#a6e22e">Resource</span>: <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Resource</span>}] = <span style="color:#66d9ef">struct</span>{}{}
	}
	<span style="color:#75715e">// 4. 初始化 gc controller 对象
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">garbageCollector</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">garbagecollector</span>.<span style="color:#a6e22e">NewGarbageCollector</span>(
		<span style="color:#a6e22e">metadataClient</span>,
		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">RESTMapper</span>,
		<span style="color:#a6e22e">ignoredResources</span>,
		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">ObjectOrMetadataInformerFactory</span>,
		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">InformersStarted</span>,
	)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to start the generic garbage collector: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
	}

	<span style="color:#75715e">// 5. 启动 gc，workers 默认是 20
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">workers</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">GarbageCollectorController</span>.<span style="color:#a6e22e">ConcurrentGCSyncs</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">garbageCollector</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">workers</span>, <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Stop</span>)

	<span style="color:#75715e">// Periodically refresh the RESTMapper with new discovery information and sync
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the garbage collector.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 6. 监听集群中的资源，周期更新
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">garbageCollector</span>.<span style="color:#a6e22e">Sync</span>(<span style="color:#a6e22e">gcClientset</span>.<span style="color:#a6e22e">Discovery</span>(), <span style="color:#ae81ff">30</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>, <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Stop</span>)

	<span style="color:#75715e">// 7. 注册 debug 接口
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">garbagecollector</span>.<span style="color:#a6e22e">NewDebugHandler</span>(<span style="color:#a6e22e">garbageCollector</span>), <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">nil</span>
}
</code></pre></div><p>在 <code>startGarbageCollectorController()</code> 中主要调用了 4 个方法：</p>
<ul>
<li><code>garbagecollector.NewGarbageCollector()</code></li>
<li><code>garbageCollector.Run()</code></li>
<li><code>garbageCollector.Sync()</code></li>
<li><code>garbagecollector.NewDebugHandler()</code>
其中 <code>garbagecollector.NewGarbageCollector()</code> 只是初始化 GarbageCollector 和 GraphBuilder 对象，核心逻辑都在 Run() 和 Sync() 中，下面分别来看这几个方法分别做了那些事。</li>
</ul>
<h3 id="211-garbagecollectorrun">
  2.1.1 garbageCollector.Run()
  <a class="anchor" href="#211-garbagecollectorrun">#</a>
</h3>
<p><code>garbageCollector.Run()</code> 方法主要作用是启动生产者和消费者。生产者就是 monitors，监听集群中的资源对象，将产生的新事件分别放入 <code>attemptToDelete</code> 和 <code>attemptToOrphan</code> 两个队列中。消费者就是处理这 2 个队列中的事件，要么删除对象，要么更新对象依赖关系。该方法的核心在于 <code>gc.dependencyGraphBuilder.Run()</code> 启动生产者和 for 循环启动消费者。</p>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:122</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">workers</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}) {
	<span style="color:#f92672">...</span>

	<span style="color:#75715e">// 1. 启动所有 monitors 即 informers，监听集群资源
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 并启动一个协程，处理 graphChanges 中事件，
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 然后经过处理，分别放入 GraphBuilder 的 attemptToDelete 和 attemptToOrphan 两个队列中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">stopCh</span>)
	
	<span style="color:#75715e">// 2. 等待 informers 的 cache 同步完成
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">WaitForNamedCacheSync</span>(<span style="color:#e6db74">&#34;garbage collector&#34;</span>, <span style="color:#a6e22e">stopCh</span>, <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">IsSynced</span>) {
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Garbage collector: all resource monitors have synced. Proceeding to collect garbage&#34;</span>)

	<span style="color:#75715e">// gc workers
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">workers</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#75715e">// 3. 启动多个协程，处理 attemptToDelete 队列中的事件
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">wait</span>.<span style="color:#a6e22e">Until</span>(<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">runAttemptToDeleteWorker</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>, <span style="color:#a6e22e">stopCh</span>)
		<span style="color:#75715e">// 4. 启动多个协程，处理 attemptToOrphan 队列中的事件
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">wait</span>.<span style="color:#a6e22e">Until</span>(<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">runAttemptToOrphanWorker</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>, <span style="color:#a6e22e">stopCh</span>)
	}

	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">stopCh</span>
}
</code></pre></div><p><strong>GraphBuilder</strong>
GraphBuilder 在整个垃圾收集的过程中，起到了承上启下的作用。首先看下它的结构：</p>
<p><code>pkg/controller/garbagecollector/graph_builder.go:73</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GraphBuilder</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">restMapper</span> <span style="color:#a6e22e">meta</span>.<span style="color:#a6e22e">RESTMapper</span>

	<span style="color:#75715e">// monitor 就是 informer，一个 monitor list/watch 一种资源
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">monitors</span>    <span style="color:#a6e22e">monitors</span>
	<span style="color:#a6e22e">monitorLock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
	
	<span style="color:#75715e">// 当 kube-controller-manager 中所有的 controllers 都启动后，就会被 close 掉
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">informersStarted</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}

	<span style="color:#75715e">// stopCh 是接收 shutdown 信号
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}

	<span style="color:#75715e">// 当调用 GraphBuilder 的 run 方法时，running 会被设置为 true
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">running</span> <span style="color:#66d9ef">bool</span>

	<span style="color:#a6e22e">metadataClient</span> <span style="color:#a6e22e">metadata</span>.<span style="color:#a6e22e">Interface</span>
	
	<span style="color:#75715e">// monitors 监听到的事件会放在 graphChanges 中
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">graphChanges</span> <span style="color:#a6e22e">workqueue</span>.<span style="color:#a6e22e">RateLimitingInterface</span>
	
	<span style="color:#75715e">// uidToNode 维护所有对象的依赖关系
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">uidToNode</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">concurrentUIDToNode</span>
	
	<span style="color:#75715e">// GarbageCollector 作为消费者要处理 attemptToDelete 和 attemptToOrphan 两个队列中的事件
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">attemptToDelete</span> <span style="color:#a6e22e">workqueue</span>.<span style="color:#a6e22e">RateLimitingInterface</span>
	<span style="color:#a6e22e">attemptToOrphan</span> <span style="color:#a6e22e">workqueue</span>.<span style="color:#a6e22e">RateLimitingInterface</span>
	
	<span style="color:#75715e">// absentOwnerCache 存放已知不存在的对象
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">absentOwnerCache</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">UIDCache</span>
	<span style="color:#a6e22e">sharedInformers</span>  <span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">InformerFactory</span>
	<span style="color:#75715e">// 不需要被 gc 的资源，默认是空
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ignoredResources</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupResource</span>]<span style="color:#66d9ef">struct</span>{}
}
</code></pre></div><p>其中 <code>uidToNode</code> 字段作为维护对象之间依赖关系，比如创建一个 Deployment 时，会创建 ReplicaSet，ReplicaSet 才会创建 Pod。那么 Pod 的 owner 是 ReplicaSet，ReplicaSet 的 owner 是 Deployment。<code>uidToNode</code> 字段的结构定义如下：</p>
<p><code>pkg/controller/garbagecollector/graph.go:162</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">concurrentUIDToNode</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">uidToNodeLock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
	<span style="color:#a6e22e">uidToNode</span>     <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">UID</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">identity</span> <span style="color:#a6e22e">objectReference</span>

	<span style="color:#a6e22e">dependentsLock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>

	<span style="color:#75715e">// dependents 保存的是 owner 是自己的对象集合
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dependents</span> <span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>]<span style="color:#66d9ef">struct</span>{}
	<span style="color:#75715e">// this is set by processGraphChanges() if the object has non-nil DeletionTimestamp
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// and has the FinalizerDeleteDependents.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">deletingDependents</span>     <span style="color:#66d9ef">bool</span>
	<span style="color:#a6e22e">deletingDependentsLock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
	<span style="color:#75715e">// this records if the object&#39;s deletionTimestamp is non-nil.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">beingDeleted</span>     <span style="color:#66d9ef">bool</span>
	<span style="color:#a6e22e">beingDeletedLock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
	
	<span style="color:#75715e">// 如果 virtual 为 true，表示这个对象不是通过 informer 观察到的，是虚拟构建的
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">virtual</span>     <span style="color:#66d9ef">bool</span>
	<span style="color:#a6e22e">virtualLock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
	
	<span style="color:#75715e">// owners 保存的是自己的 owner
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">owners</span> []<span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">OwnerReference</span>
}
</code></pre></div><p><code>GraphBuilder</code> 主要有三个功能：</p>
<ol>
<li>监控集群中所有的可删除资源；</li>
<li>基于 informers 中的资源在 <code>uidToNode</code> 数据结构中维护着所有对象的依赖关系；</li>
<li>处理 graphChanges 中的事件并放到 <code>attemptToDelete</code> 和 <code>attemptToOrphan</code> 两个队列中；</li>
</ol>
<p><strong>gc.dependencyGraphBuilder.Run()</strong>
继续回到 <code>gc.dependencyGraphBuilder.Run()</code> 方法，它的功能上文已经提到，就是启动生产者。代码如下：</p>
<p><code>pkg/controller/garbagecollector/graph_builder.go:290</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gb</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GraphBuilder</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}) {
	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;GraphBuilder running&#34;</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;GraphBuilder stopping&#34;</span>)

	<span style="color:#75715e">// 1. 设置 stop channel
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">monitorLock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">stopCh</span> = <span style="color:#a6e22e">stopCh</span>
	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">running</span> = <span style="color:#66d9ef">true</span>
	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">monitorLock</span>.<span style="color:#a6e22e">Unlock</span>()

	<span style="color:#75715e">// 2. 启动 monitor，除非 stop channel 收到信号
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">startMonitors</span>()
	<span style="color:#75715e">// 调用 gb.runProcessGraphChanges，分类事件，放入 2 个队列中
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 此处为死循环，除非收到 stopCh 信号，否则下面的代码不会被执行到
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wait</span>.<span style="color:#a6e22e">Until</span>(<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">runProcessGraphChanges</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>, <span style="color:#a6e22e">stopCh</span>)

	<span style="color:#75715e">// 代码走到这里，说明 stopCh 收到了信号，停止所有 monitor
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">monitorLock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">monitorLock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#a6e22e">monitors</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">monitors</span>
	<span style="color:#a6e22e">stopped</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">monitor</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">monitors</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">monitor</span>.<span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">stopped</span><span style="color:#f92672">++</span>
			close(<span style="color:#a6e22e">monitor</span>.<span style="color:#a6e22e">stopCh</span>)
		}
	}

	<span style="color:#75715e">// reset monitors so that the graph builder can be safely re-run/synced.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">monitors</span> = <span style="color:#66d9ef">nil</span>
	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;stopped %d of %d monitors&#34;</span>, <span style="color:#a6e22e">stopped</span>, len(<span style="color:#a6e22e">monitors</span>))
}
</code></pre></div><p>继续看 <code>gb.runProcessGraphChanges()</code> 方法，这里是生产者的核心逻辑。总结一下：</p>
<ol>
<li>从 <code>graphChanges</code> 队列中取出一个 item 即 event；</li>
<li>获取 event 的 accessor，accessor 是一个 object 的 meta.Interface，里面包含访问 object meta 中所有字段的方法；</li>
<li>通过 accessor 获取 UID 判断 <code>uidToNode</code> 中是否存在该 object；</li>
</ol>
<p>根据对象是否存在以及事件类型，分成三种情况</p>
<ul>
<li>若 <code>uidToNode</code> 中不存在该 node 且该事件是 addEvent 或 updateEvent</li>
</ul>
<p>则为该 object 创建对应的 node，并调用 <code>gb.insertNode()</code> 将该 node 加到 <code>uidToNode</code> 中，然后将该 node 添加到其 owner 的 dependents 中，执行完 <code>gb.insertNode()</code> 中的操作后再调用 <code>gb.processTransitions()</code> 方法判断该对象是否处于删除状态，若处于删除状态会判断该对象是以 orphan 模式删除还是以 foreground 模式删除，若以 orphan 模式删除，则将该 node 加入到 <code>attemptToOrphan</code> 队列中，若以 foreground 模式删除则将该对象以及其所有 dependents 都加入到 <code>attemptToDelete</code> 队列中；</p>
<ul>
<li>若 <code>uidToNode</code> 中存在该 node 且该事件是 addEvent 或 updateEvent</li>
</ul>
<p>此时可能是一个 update 操作，调用 <code>referencesDiffs()</code> 方法检查该对象的 OwnerReferences 字段是否有变化，若有变化</p>
<ol>
<li>调用 <code>gb.addUnblockedOwnersToDeleteQueue()</code> 将被删除以及更新的 owner 对应的 node 加入到 <code>attemptToDelete</code> 中，因为此时该 node 中已被删除或更新的 owner 可能处于删除状态且阻塞在该 node 处，此时有三种方式避免该 node 的 owner 处于删除阻塞状态，一是等待该 node 被删除，二是将该 node 自身对应 owner 的 <code>OwnerReferences </code>字段删除，三是将该 node 的 <code>OwnerReferences</code> 字段中对应 owner 的 <code>BlockOwnerDeletion</code> 设置为 false；</li>
<li>更新该 node 的 owners 列表；</li>
<li>若有新增的 owner，将该 node 加入到新 owner 的 dependents 中；</li>
<li>若有被删除的 owner，将该 node 从已删除 owner 的 dependents 中删除；以上操作完成后，检查该 node 是否处于删除状态并进行标记，最后调用 <code>gb.processTransitions()</code> 方法检查该 node 是否要被删除；</li>
</ol>
<p>举个例子，若以 foreground 模式删除 deployment 时，deployment 的 dependents 列表中有对应的 rs，那么 deployment 的删除会阻塞住等待其依赖 rs 的删除，此时 rs 有三种方法不阻塞 deployment 的删除操作，一是 rs 对象被删除，二是删除 rs 对象 OwnerReferences 字段中对应的 deployment，三是将 rs 对象 OwnerReferences 字段中对应的 deployment 配置 BlockOwnerDeletion 设置为 false，文末会有示例演示该操作。</p>
<ul>
<li>若该事件为 deleteEvent
首先从 <code>uidToNode</code> 中删除该对象，然后从该 node 所有 owners 的 dependents 中删除该对象，将该 node 所有的 dependents 加入到 <code>attemptToDelete</code> 队列中，最后检查该 node 的所有 owners，若有处于删除状态的 owner，此时该 owner 可能处于删除阻塞状态正在等待该 node 的删除，将该 owner 加入到 <code>attemptToDelete</code> 中；</li>
</ul>
<p><code>pkg/controller/garbagecollector/graph_builder.go:530</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gb</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GraphBuilder</span>) <span style="color:#a6e22e">runProcessGraphChanges</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">processGraphChanges</span>() {
	}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gb</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GraphBuilder</span>) <span style="color:#a6e22e">processGraphChanges</span>() <span style="color:#66d9ef">bool</span> {
	<span style="color:#75715e">// 1. 从 graphChanges 取出一个 event
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">quit</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">graphChanges</span>.<span style="color:#a6e22e">Get</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">quit</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">graphChanges</span>.<span style="color:#a6e22e">Done</span>(<span style="color:#a6e22e">item</span>)
	<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">item</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">event</span>)
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;expect a *event, got %v&#34;</span>, <span style="color:#a6e22e">item</span>))
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#a6e22e">obj</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">obj</span>
	<span style="color:#a6e22e">accessor</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">meta</span>.<span style="color:#a6e22e">Accessor</span>(<span style="color:#a6e22e">obj</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;cannot access obj: %v&#34;</span>, <span style="color:#a6e22e">err</span>))
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;GraphBuilder process object: %s/%s, namespace %s, name %s, uid %s, event type %v&#34;</span>, <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">gvk</span>.<span style="color:#a6e22e">GroupVersion</span>().<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">gvk</span>.<span style="color:#a6e22e">Kind</span>, <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetNamespace</span>(), <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetName</span>(), string(<span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetUID</span>()), <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">eventType</span>)
	<span style="color:#75715e">// 2. 若存在 node 对象，从 uidToNode 中取出该 event 的 node 对象
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">existingNode</span>, <span style="color:#a6e22e">found</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">uidToNode</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetUID</span>())
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">found</span> {
		<span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">markObserved</span>()
	}
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#75715e">// 3.1 若 event 为 add 或 update 类型且对应的 node 对象不存在时，表示新建对象
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> (<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">eventType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">addEvent</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">eventType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">updateEvent</span>) <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">found</span>:
		<span style="color:#75715e">// 3.1.1 为 node 创建 event 对象
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">newNode</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">node</span>{
			<span style="color:#a6e22e">identity</span>: <span style="color:#a6e22e">objectReference</span>{
				<span style="color:#a6e22e">OwnerReference</span>: <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">OwnerReference</span>{
					<span style="color:#a6e22e">APIVersion</span>: <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">gvk</span>.<span style="color:#a6e22e">GroupVersion</span>().<span style="color:#a6e22e">String</span>(),
					<span style="color:#a6e22e">Kind</span>:       <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">gvk</span>.<span style="color:#a6e22e">Kind</span>,
					<span style="color:#a6e22e">UID</span>:        <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetUID</span>(),
					<span style="color:#a6e22e">Name</span>:       <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetName</span>(),
				},
				<span style="color:#a6e22e">Namespace</span>: <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetNamespace</span>(),
			},
			<span style="color:#a6e22e">dependents</span>:         make(<span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>]<span style="color:#66d9ef">struct</span>{}),
			<span style="color:#a6e22e">owners</span>:             <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetOwnerReferences</span>(),
			<span style="color:#a6e22e">deletingDependents</span>: <span style="color:#a6e22e">beingDeleted</span>(<span style="color:#a6e22e">accessor</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">hasDeleteDependentsFinalizer</span>(<span style="color:#a6e22e">accessor</span>),
			<span style="color:#a6e22e">beingDeleted</span>:       <span style="color:#a6e22e">beingDeleted</span>(<span style="color:#a6e22e">accessor</span>),
		}
		<span style="color:#75715e">// 3.1.2 在 uidToNode 中添加该 node 对象
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">insertNode</span>(<span style="color:#a6e22e">newNode</span>)
		<span style="color:#75715e">// 3.1.3 检查对象的删除策略，并放到对应的队列中
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">processTransitions</span>(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">oldObj</span>, <span style="color:#a6e22e">accessor</span>, <span style="color:#a6e22e">newNode</span>)
	<span style="color:#75715e">// 3.2 若 event 为 add 或 update 类型且对应的 node 对象存在时，表示更新对象
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> (<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">eventType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">addEvent</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">eventType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">updateEvent</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">found</span>:
		<span style="color:#75715e">// 3.2.1 检查当前对象和老对象的 owner 的不同
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">added</span>, <span style="color:#a6e22e">removed</span>, <span style="color:#a6e22e">changed</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">referencesDiffs</span>(<span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">owners</span>, <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetOwnerReferences</span>())
		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">added</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">removed</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">changed</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#75715e">// 3.2.2 检查依赖变更是否解除了处于等待依赖删除的 owner 的阻塞状态
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">addUnblockedOwnersToDeleteQueue</span>(<span style="color:#a6e22e">removed</span>, <span style="color:#a6e22e">changed</span>)
			<span style="color:#75715e">// 3.2.3 更新 node 本身
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">owners</span> = <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetOwnerReferences</span>()
			<span style="color:#75715e">// 3.2.4 添加 node 到它的 owner 依赖中
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">addDependentToOwners</span>(<span style="color:#a6e22e">existingNode</span>, <span style="color:#a6e22e">added</span>)
			<span style="color:#75715e">// 3.2.5 删除老的 owners 中的依赖
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">removeDependentFromOwners</span>(<span style="color:#a6e22e">existingNode</span>, <span style="color:#a6e22e">removed</span>)
		}

		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">beingDeleted</span>(<span style="color:#a6e22e">accessor</span>) {
			<span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">markBeingDeleted</span>()
		}
		<span style="color:#75715e">// 3.2.6 检查对象的删除策略，并放到对应的队列中
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">processTransitions</span>(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">oldObj</span>, <span style="color:#a6e22e">accessor</span>, <span style="color:#a6e22e">existingNode</span>)
	<span style="color:#75715e">// 3.3 若为 delete event
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">eventType</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">deleteEvent</span>:
		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">found</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;%v doesn&#39;t exist in the graph, this shouldn&#39;t happen&#34;</span>, <span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetUID</span>())
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
		}
		<span style="color:#75715e">// 3.3.1 从 uidToNode 中删除该 node
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">removeNode</span>(<span style="color:#a6e22e">existingNode</span>)
		<span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">dependentsLock</span>.<span style="color:#a6e22e">RLock</span>()
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">dependentsLock</span>.<span style="color:#a6e22e">RUnlock</span>()
		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">dependents</span>) &gt; <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">absentOwnerCache</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">accessor</span>.<span style="color:#a6e22e">GetUID</span>())
		}
		<span style="color:#75715e">// 3.3.2 删除该 node 的 dependents
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">dep</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">dependents</span> {
			<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">attemptToDelete</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">dep</span>)
		}
		<span style="color:#75715e">// 3.3.2 删除该 node 处于删除阻塞状态的 owner
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">owner</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">existingNode</span>.<span style="color:#a6e22e">owners</span> {
			<span style="color:#a6e22e">ownerNode</span>, <span style="color:#a6e22e">found</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">uidToNode</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">UID</span>)
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">found</span> <span style="color:#f92672">||</span> !<span style="color:#a6e22e">ownerNode</span>.<span style="color:#a6e22e">isDeletingDependents</span>() {
				<span style="color:#66d9ef">continue</span>
			}
			<span style="color:#a6e22e">gb</span>.<span style="color:#a6e22e">attemptToDelete</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">ownerNode</span>)
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><h3 id="212-gcrunattempttodeleteworker">
  2.1.2 gc.runAttemptToDeleteWorker()
  <a class="anchor" href="#212-gcrunattempttodeleteworker">#</a>
</h3>
<p><code>gc.runAttemptToDeleteWorker()</code> 方法就是将 <code>attemptToDelete</code> 队列中的对象取出，并删除，如果删除失败则重进队列重试。</p>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:285</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">runAttemptToDeleteWorker</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToDeleteWorker</span>() {
	}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">attemptToDeleteWorker</span>() <span style="color:#66d9ef">bool</span> {
	<span style="color:#75715e">// 取出对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">quit</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToDelete</span>.<span style="color:#a6e22e">Get</span>()
	<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">workerLock</span>.<span style="color:#a6e22e">RLock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">workerLock</span>.<span style="color:#a6e22e">RUnlock</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">quit</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToDelete</span>.<span style="color:#a6e22e">Done</span>(<span style="color:#a6e22e">item</span>)
	<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">item</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>)
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;expect *node, got %#v&#34;</span>, <span style="color:#a6e22e">item</span>))
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
    <span style="color:#75715e">// 实际执行删除的方法 gc.attemptToDeleteItem()
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToDeleteItem</span>(<span style="color:#a6e22e">n</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">restMappingError</span>); <span style="color:#a6e22e">ok</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;error syncing item %s: %v&#34;</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;error syncing item %s: %v&#34;</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span>))
		}
        <span style="color:#75715e">// 删除失败则重新进入队列等待重试
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToDelete</span>.<span style="color:#a6e22e">AddRateLimited</span>(<span style="color:#a6e22e">item</span>)
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">isObserved</span>() {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;item %s hasn&#39;t been observed via informer yet&#34;</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#75715e">// 如果 node 不是 informer 发现的，则也要删除
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToDelete</span>.<span style="color:#a6e22e">AddRateLimited</span>(<span style="color:#a6e22e">item</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><p><code>gc.runAttemptToDeleteWorker()</code> 中调用了 <code>gc.attemptToDeleteItem()</code> 执行实际的删除操作。下面继续来看 <code>gc.attemptToDeleteItem()</code> 的实现细节：</p>
<ol>
<li>判断 node 是否处于删除状态；</li>
<li>从 apiserver 获取该 node 最新的状态，该 node 可能为 virtual node，若为 virtual node 则从 apiserver 中获取不到该 node 的对象，此时会将该 node 重新加入到 graphChanges 队列中，再次处理该 node 时会将其从 uidToNode 中删除；</li>
<li>判断该 node 最新状态的 uid 是否等于本地缓存中的 uid，若不匹配说明该 node 已更新过此时将其设置为 virtual node 并重新加入到 graphChanges 队列中，再次处理该 node 时会将其从 uidToNode 中删除；</li>
<li>通过 node 的 deletingDependents 字段判断该 node 当前是否处于删除 dependents 的状态，若该 node 处于删除 dependents 的状态则调用 processDeletingDependentsItem 方法检查 node 的 blockingDependents 是否被完全删除，若 blockingDependents 已完全被删除则删除该 node 对应的 finalizer，若 blockingDependents 还未删除完，将未删除的 blockingDependents 加入到 attemptToDelete 中；上文中在 GraphBuilder 处理 graphChanges 中的事件时，若发现 node 处于删除状态，会将 node 的 dependents 加入到 attemptToDelete 中并标记 node 的 deletingDependents 为 true；</li>
<li>调用 gc.classifyReferences 将 node 的 ownerReferences 分类为 solid, dangling, waitingForDependentsDeletion 三类：dangling(owner 不存在）、waitingForDependentsDeletion(owner 存在，owner 处于删除状态且正在等待其 dependents 被删除）、solid（至少有一个 owner 存在且不处于删除状态）；对以上分类进行不同的处理：
<ol>
<li>第一种情况是若 solid 不为 0 即当前 node 至少存在一个 owner，该对象还不能被回收，此时需要将 dangling 和 waitingForDependentsDeletion 列表中的 owner 从 node 的 ownerReferences 删除，即已经被删除或等待删除的引用从对象中删掉；</li>
<li>第二种情况是该 node 的 owner 处于 waitingForDependentsDeletion 状态并且 node 的 dependents 未被完全删除，该 node 需要等待删除完所有的 dependents 后才能被删除；</li>
<li>第三种情况就是该 node 已经没有任何 dependents 了，此时按照 node 中声明的删除策略调用 apiserver 的接口删除即可；</li>
</ol>
</li>
</ol>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:409</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">attemptToDeleteItem</span>(<span style="color:#a6e22e">item</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">InfoS</span>(<span style="color:#e6db74">&#34;Processing object&#34;</span>, <span style="color:#e6db74">&#34;object&#34;</span>, <span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">KRef</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">Name</span>),
		<span style="color:#e6db74">&#34;objectUID&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">UID</span>, <span style="color:#e6db74">&#34;kind&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">Kind</span>)

	<span style="color:#75715e">// 1. 判断 node 是否处于删除状态
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">isBeingDeleted</span>() <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">isDeletingDependents</span>() {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;processing item %s returned at once, because its DeletionTimestamp is non-nil&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}
	
	<span style="color:#75715e">// 2. 从 apiserver 获取该 node 最新的状态
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">latest</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">getObject</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">IsNotFound</span>(<span style="color:#a6e22e">err</span>):
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;item %v not found, generating a virtual delete event&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">enqueueVirtualDeleteEvent</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">markObserved</span>()
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>:
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	
	<span style="color:#75715e">// 3. 判断该 node 最新状态的 uid 是否等于本地缓存中的 uid
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">latest</span>.<span style="color:#a6e22e">GetUID</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">UID</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;UID doesn&#39;t match, item %v not found, generating a virtual delete event&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">enqueueVirtualDeleteEvent</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">markObserved</span>()
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}

	<span style="color:#75715e">// 4. 判断该 node 当前是否处于删除 dependents 状态中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">isDeletingDependents</span>() {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">processDeletingDependentsItem</span>(<span style="color:#a6e22e">item</span>)
	}
	
	<span style="color:#75715e">// 5. 检查 node 是否还存在 ownerReferences
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ownerReferences</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">latest</span>.<span style="color:#a6e22e">GetOwnerReferences</span>()
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">ownerReferences</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;object %s&#39;s doesn&#39;t have an owner, continue on next item&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}
	
	<span style="color:#75715e">// 6. 对 ownerReferences 进行分类
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">solid</span>, <span style="color:#a6e22e">dangling</span>, <span style="color:#a6e22e">waitingForDependentsDeletion</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">classifyReferences</span>(<span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">ownerReferences</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;classify references of %s.\nsolid: %#v\ndangling: %#v\nwaitingForDependentsDeletion: %#v\n&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">solid</span>, <span style="color:#a6e22e">dangling</span>, <span style="color:#a6e22e">waitingForDependentsDeletion</span>)

	<span style="color:#66d9ef">switch</span> {
	<span style="color:#75715e">// 7.1 存在不处于删除状态的 owner
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> len(<span style="color:#a6e22e">solid</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;object %#v has at least one existing owner: %#v, will not garbage collect&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">solid</span>)
		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">dangling</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">waitingForDependentsDeletion</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
		}
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;remove dangling references %#v and waiting references %#v for object %s&#34;</span>, <span style="color:#a6e22e">dangling</span>, <span style="color:#a6e22e">waitingForDependentsDeletion</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#a6e22e">ownerUIDs</span> <span style="color:#f92672">:=</span> append(<span style="color:#a6e22e">ownerRefsToUIDs</span>(<span style="color:#a6e22e">dangling</span>), <span style="color:#a6e22e">ownerRefsToUIDs</span>(<span style="color:#a6e22e">waitingForDependentsDeletion</span>)<span style="color:#f92672">...</span>)
		<span style="color:#a6e22e">patch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">deleteOwnerRefStrategicMergePatch</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">UID</span>, <span style="color:#a6e22e">ownerUIDs</span><span style="color:#f92672">...</span>)
		<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">patch</span>(<span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">patch</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">deleteOwnerRefJSONMergePatch</span>(<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ownerUIDs</span><span style="color:#f92672">...</span>)
		})
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	<span style="color:#75715e">// 7.2 node 的 owner 处于 waitingForDependentsDeletion 状态并且 node 的 dependents 未被完全删除
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> len(<span style="color:#a6e22e">waitingForDependentsDeletion</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">dependentsLength</span>() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
		<span style="color:#a6e22e">deps</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">getDependents</span>()
		<span style="color:#75715e">// 删除 dependents
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">dep</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">deps</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dep</span>.<span style="color:#a6e22e">isDeletingDependents</span>() {
				<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;processing object %s, some of its owners and its dependent [%s] have FinalizerDeletingDependents, to prevent potential cycle, its ownerReferences are going to be modified to be non-blocking, then the object is going to be deleted with Foreground&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">dep</span>.<span style="color:#a6e22e">identity</span>)
				<span style="color:#a6e22e">patch</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">unblockOwnerReferencesStrategicMergePatch</span>()
				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
					<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
				}
				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">patch</span>(<span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">patch</span>, <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">unblockOwnerReferencesJSONMergePatch</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
					<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
				}
				<span style="color:#66d9ef">break</span>
			}
		}
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;at least one owner of object %s has FinalizerDeletingDependents, and the object itself has dependents, so it is going to be deleted in Foreground&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>)
		<span style="color:#75715e">// 以 Foreground 模式删除 node 对象
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">policy</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">DeletePropagationForeground</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">deleteObject</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">policy</span>)
	<span style="color:#75715e">// 7.3 该 node 已经没有任何依赖了，按照 node 中声明的删除策略调用 apiserver 的接口删除
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">default</span>:
		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">policy</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">DeletionPropagation</span>
		<span style="color:#66d9ef">switch</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">hasOrphanFinalizer</span>(<span style="color:#a6e22e">latest</span>):
			<span style="color:#a6e22e">policy</span> = <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">DeletePropagationOrphan</span>
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">hasDeleteDependentsFinalizer</span>(<span style="color:#a6e22e">latest</span>):
			<span style="color:#a6e22e">policy</span> = <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">DeletePropagationForeground</span>
		<span style="color:#66d9ef">default</span>:
			<span style="color:#a6e22e">policy</span> = <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">DeletePropagationBackground</span>
		}
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">InfoS</span>(<span style="color:#e6db74">&#34;Deleting object&#34;</span>, <span style="color:#e6db74">&#34;object&#34;</span>, <span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">KRef</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">Name</span>),
			<span style="color:#e6db74">&#34;objectUID&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">UID</span>, <span style="color:#e6db74">&#34;kind&#34;</span>, <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>.<span style="color:#a6e22e">Kind</span>, <span style="color:#e6db74">&#34;propagationPolicy&#34;</span>, <span style="color:#a6e22e">policy</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">deleteObject</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">policy</span>)
	}
}
</code></pre></div><h3 id="213-gcrunattempttoorphanworker">
  2.1.3 gc.runAttemptToOrphanWorker()
  <a class="anchor" href="#213-gcrunattempttoorphanworker">#</a>
</h3>
<p><code>gc.runAttemptToOrphanWorker()</code> 是处理以 Orphan 模式删除的 node，主要逻辑为：</p>
<ol>
<li>调用 <code>gc.orphanDependents()</code> 删除 owner 所有 dependents OwnerReferences 中的 owner 字段；</li>
<li>调用 <code>gc.removeFinalizer()</code> 删除 owner 的 orphan Finalizer；</li>
<li>以上两步中若有失败的会进行重试；</li>
</ol>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:602</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">attemptToOrphanWorker</span>() <span style="color:#66d9ef">bool</span> {
	<span style="color:#a6e22e">item</span>, <span style="color:#a6e22e">quit</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToOrphan</span>.<span style="color:#a6e22e">Get</span>()
	<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">workerLock</span>.<span style="color:#a6e22e">RLock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">workerLock</span>.<span style="color:#a6e22e">RUnlock</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">quit</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToOrphan</span>.<span style="color:#a6e22e">Done</span>(<span style="color:#a6e22e">item</span>)
	<span style="color:#a6e22e">owner</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">item</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>)
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;expect *node, got %#v&#34;</span>, <span style="color:#a6e22e">item</span>))
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#75715e">// we don&#39;t need to lock each element, because they never get updated
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">dependentsLock</span>.<span style="color:#a6e22e">RLock</span>()
	<span style="color:#a6e22e">dependents</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">dependents</span>))
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">dependent</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">dependents</span> {
		<span style="color:#a6e22e">dependents</span> = append(<span style="color:#a6e22e">dependents</span>, <span style="color:#a6e22e">dependent</span>)
	}
	<span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">dependentsLock</span>.<span style="color:#a6e22e">RUnlock</span>()

	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">orphanDependents</span>(<span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">dependents</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;orphanDependents for %s failed with %v&#34;</span>, <span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">err</span>))
		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToOrphan</span>.<span style="color:#a6e22e">AddRateLimited</span>(<span style="color:#a6e22e">item</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#75715e">// update the owner, remove &#34;orphaningFinalizer&#34; from its finalizers list
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">removeFinalizer</span>(<span style="color:#a6e22e">owner</span>, <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">FinalizerOrphanDependents</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;removeOrphanFinalizer for %s failed with %v&#34;</span>, <span style="color:#a6e22e">owner</span>.<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">err</span>))
		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">attemptToOrphan</span>.<span style="color:#a6e22e">AddRateLimited</span>(<span style="color:#a6e22e">item</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}
</code></pre></div><h3 id="214-小结">
  2.1.4 小结
  <a class="anchor" href="#214-%e5%b0%8f%e7%bb%93">#</a>
</h3>
<p>上面的业务逻辑不算复杂，但是方法嵌套有点多，整理一下方法的调用链：</p>


<script src="/mermaid.min.js"></script>

  <script>mermaid.initialize({
  "flowchart": {
    "useMaxWidth":true
  },
  "theme": "default"
}
)</script>




<p class="mermaid">
graph LR

p1(garbageCollector.Run) --> p11(gc.dependencyGraphBuilder.Run)

p11 --> p111(gb.startMonitors)

p11 --> p112(gb.runProcessGraphChanges)

p112 --> p1121(gb.processGraphChanges)

p1121 --> p11211(gb.processTransitions)

p1 --> p12(gc.runAttemptToDeleteWorker)

p12 --> p121(gc.attemptToDeleteWorker)

p121 --> p1211(gc.attemptToDeleteItem)

p1 --> p13(gc.runAttemptToOrphanWorker)

p13 --> p131(gc.orphanDependents)

p13 --> p132(gc.removeFinalizer)
</p>

<h2 id="22-garbagecollectorsync">
  2.2 garbageCollector.Sync()
  <a class="anchor" href="#22-garbagecollectorsync">#</a>
</h2>
<p><code>garbageCollector.Sync()</code> 方法主要是周期性地查询集群中的所有资源，过滤出 deletableResource，然后对比已经监控的 deletableResource 是否一致，如果不一致，则更新 GraphBuilder 的 monitors，并重启 monitors 监控新拿到的 deletableResource。主要逻辑：</p>
<ol>
<li>通过调用 <code>GetDeletableResources()</code> 获取集群内所有的 deletableResources 作为 newResources，deletableResources 指支持 “delete”, “list”, “watch” 三种操作的 resource，包括自定义资源</li>
<li>检查 oldResources, newResources 是否一致，不一致则需要同步；</li>
<li>调用 <code>gc.resyncMonitors()</code> 同步 newResources，在 <code>gc.resyncMonitors()</code> 中会重新调用 GraphBuilder 的 <code>syncMonitors()</code> 和 <code>startMonitors()</code> 两个方法完成 monitors 的刷新；</li>
<li>等待 newResources informer 中的 cache 同步完成；</li>
<li>将 newResources 作为 oldResources，继续进行下一轮的同步；</li>
</ol>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:168</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">Sync</span>(<span style="color:#a6e22e">discoveryClient</span> <span style="color:#a6e22e">discovery</span>.<span style="color:#a6e22e">ServerResourcesInterface</span>, <span style="color:#a6e22e">period</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>, <span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}) {
	<span style="color:#a6e22e">oldResources</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupVersionResource</span>]<span style="color:#66d9ef">struct</span>{})
	<span style="color:#a6e22e">wait</span>.<span style="color:#a6e22e">Until</span>(<span style="color:#66d9ef">func</span>() {
		<span style="color:#75715e">// 1. 获取集群内所有的 deletableResources 作为 newResources
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">newResources</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">GetDeletableResources</span>(<span style="color:#a6e22e">discoveryClient</span>)

		<span style="color:#75715e">// 正常情况下是不会走到这里，除非发生内部错误
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">newResources</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;no resources reported by discovery, skipping garbage collector sync&#34;</span>)
			<span style="color:#66d9ef">return</span>
		}

		<span style="color:#75715e">// 2. 判断集群中的资源是否有变化
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">oldResources</span>, <span style="color:#a6e22e">newResources</span>) {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;no resource updates from discovery, skipping garbage collector sync&#34;</span>)
			<span style="color:#66d9ef">return</span>
		}

		<span style="color:#75715e">// 加锁保证在 informer 同步完成后处理 event
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">workerLock</span>.<span style="color:#a6e22e">Lock</span>()
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">workerLock</span>.<span style="color:#a6e22e">Unlock</span>()

		<span style="color:#75715e">// 3. 开始更新 GraphBuilder 中的 monitors
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">attempt</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">wait</span>.<span style="color:#a6e22e">PollImmediateUntil</span>(<span style="color:#ae81ff">100</span><span style="color:#f92672">*</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>, <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">error</span>) {
			<span style="color:#a6e22e">attempt</span><span style="color:#f92672">++</span>

			<span style="color:#75715e">// 尝试次数大于 1，先判断 deletableResource 是否改变
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">attempt</span> &gt; <span style="color:#ae81ff">1</span> {
				<span style="color:#a6e22e">newResources</span> = <span style="color:#a6e22e">GetDeletableResources</span>(<span style="color:#a6e22e">discoveryClient</span>)
				<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">newResources</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
					<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;no resources reported by discovery (attempt %d)&#34;</span>, <span style="color:#a6e22e">attempt</span>)
					<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
				}
			}

			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;syncing garbage collector with updated resources from discovery (attempt %d): %s&#34;</span>, <span style="color:#a6e22e">attempt</span>, <span style="color:#a6e22e">printDiff</span>(<span style="color:#a6e22e">oldResources</span>, <span style="color:#a6e22e">newResources</span>))

			<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">restMapper</span>.<span style="color:#a6e22e">Reset</span>()
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">4</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;reset restmapper&#34;</span>)

			<span style="color:#75715e">// 4. 调用 gc.resyncMonitors 同步 newResources
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">resyncMonitors</span>(<span style="color:#a6e22e">newResources</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;failed to sync resource monitors (attempt %d): %v&#34;</span>, <span style="color:#a6e22e">attempt</span>, <span style="color:#a6e22e">err</span>))
				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
			}
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">4</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;resynced monitors&#34;</span>)

			<span style="color:#75715e">// 5. 等待所有 monitors 的 cache 同步完成
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">WaitForNamedCacheSync</span>(<span style="color:#e6db74">&#34;garbage collector&#34;</span>, <span style="color:#a6e22e">waitForStopOrTimeout</span>(<span style="color:#a6e22e">stopCh</span>, <span style="color:#a6e22e">period</span>), <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">IsSynced</span>) {
				<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;timed out waiting for dependency graph builder sync during GC sync (attempt %d)&#34;</span>, <span style="color:#a6e22e">attempt</span>))
				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
			}

			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">nil</span>
		}, <span style="color:#a6e22e">stopCh</span>)

		<span style="color:#75715e">// 6. 更新 oldResources
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">oldResources</span> = <span style="color:#a6e22e">newResources</span>
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;synced garbage collector&#34;</span>)
	}, <span style="color:#a6e22e">period</span>, <span style="color:#a6e22e">stopCh</span>)
}
</code></pre></div><p>方法主要调用了 <code>GetDeletableResources()</code> 和 <code>gc.resyncMonitors()</code> 两个方法。前者获取集群中可删除资源，后者更新 monitors。</p>
<h3 id="221-getdeletableresources">
  2.2.1 GetDeletableResources()
  <a class="anchor" href="#221-getdeletableresources">#</a>
</h3>
<p><code>GetDeletableResources()</code> 中首先通过调用 <code>discoveryClient.ServerPreferredResources()</code> 方法获取集群内所有的 resource 信息，然后通过调用 <code>discovery.FilteredBy()</code> 过滤出支持 “delete”, “list”, “watch” 三种方法的 resource 作为 deletableResources。</p>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:658</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetDeletableResources</span>(<span style="color:#a6e22e">discoveryClient</span> <span style="color:#a6e22e">discovery</span>.<span style="color:#a6e22e">ServerResourcesInterface</span>) <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupVersionResource</span>]<span style="color:#66d9ef">struct</span>{} {
	<span style="color:#75715e">// 获取集群内所有的 resource 信息
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">preferredResources</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">discoveryClient</span>.<span style="color:#a6e22e">ServerPreferredResources</span>()
	<span style="color:#f92672">...</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">preferredResources</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupVersionResource</span>]<span style="color:#66d9ef">struct</span>{}{}
	}

	<span style="color:#75715e">// 过滤出 deletableResources
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">deletableResources</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">discovery</span>.<span style="color:#a6e22e">FilteredBy</span>(<span style="color:#a6e22e">discovery</span>.<span style="color:#a6e22e">SupportsAllVerbs</span>{<span style="color:#a6e22e">Verbs</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;delete&#34;</span>, <span style="color:#e6db74">&#34;list&#34;</span>, <span style="color:#e6db74">&#34;watch&#34;</span>}}, <span style="color:#a6e22e">preferredResources</span>)
	<span style="color:#a6e22e">deletableGroupVersionResources</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupVersionResource</span>]<span style="color:#66d9ef">struct</span>{}{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">rl</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">deletableResources</span> {
		<span style="color:#a6e22e">gv</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">ParseGroupVersion</span>(<span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">GroupVersion</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Warningf</span>(<span style="color:#e6db74">&#34;ignoring invalid discovered resource %q: %v&#34;</span>, <span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">GroupVersion</span>, <span style="color:#a6e22e">err</span>)
			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">APIResources</span> {
			<span style="color:#a6e22e">deletableGroupVersionResources</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupVersionResource</span>{<span style="color:#a6e22e">Group</span>: <span style="color:#a6e22e">gv</span>.<span style="color:#a6e22e">Group</span>, <span style="color:#a6e22e">Version</span>: <span style="color:#a6e22e">gv</span>.<span style="color:#a6e22e">Version</span>, <span style="color:#a6e22e">Resource</span>: <span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">APIResources</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">Name</span>}] = <span style="color:#66d9ef">struct</span>{}{}
		}
	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">deletableGroupVersionResources</span>
}
</code></pre></div><h3 id="222-gcresyncmonitors">
  2.2.2 gc.resyncMonitors()
  <a class="anchor" href="#222-gcresyncmonitors">#</a>
</h3>
<p><code>gc.resyncMonitors()</code> 的功能主要是更新 GraphBuilder 的 monitors 并重新启动 monitors 监控所有的 deletableResources，GraphBuilder 的 <code>startMonitors()</code> 方法在前面的流程中已经分析过，此处不再详细说明。<code>syncMonitors()</code> 只不过是拿最新的 deletableResources，把老的 monitors 字段值更新，该删的删，该加的加而已。</p>
<p><code>pkg/controller/garbagecollector/garbagecollector.go:113</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">gc</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">resyncMonitors</span>(<span style="color:#a6e22e">deletableResources</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">schema</span>.<span style="color:#a6e22e">GroupVersionResource</span>]<span style="color:#66d9ef">struct</span>{}) <span style="color:#66d9ef">error</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">syncMonitors</span>(<span style="color:#a6e22e">deletableResources</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	<span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">startMonitors</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
</code></pre></div><h2 id="23-garbagecollectornewdebughandler">
  2.3 garbagecollector.NewDebugHandler()
  <a class="anchor" href="#23-garbagecollectornewdebughandler">#</a>
</h2>
<p><code>garbagecollector.NewDebugHandler()</code> 主要功能是对外提供一个接口供用户查询当前集群中所有资源的依赖关系，依赖关系可以以图表的形式展示。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewDebugHandler</span>(<span style="color:#a6e22e">controller</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GarbageCollector</span>) <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Handler</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">debugHTTPHandler</span>{<span style="color:#a6e22e">controller</span>: <span style="color:#a6e22e">controller</span>}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">debugHTTPHandler</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Path</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;/graph&#34;</span> {
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusNotFound</span>)
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">graph</span> <span style="color:#a6e22e">graph</span>.<span style="color:#a6e22e">Directed</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">uidStrings</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Query</span>()[<span style="color:#e6db74">&#34;uid&#34;</span>]; len(<span style="color:#a6e22e">uidStrings</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">uids</span> <span style="color:#f92672">:=</span> []<span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">UID</span>{}
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">uidString</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">uidStrings</span> {
			<span style="color:#a6e22e">uids</span> = append(<span style="color:#a6e22e">uids</span>, <span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">UID</span>(<span style="color:#a6e22e">uidString</span>))
		}
		<span style="color:#a6e22e">graph</span> = <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">uidToNode</span>.<span style="color:#a6e22e">ToGonumGraphForObj</span>(<span style="color:#a6e22e">uids</span><span style="color:#f92672">...</span>)

	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">graph</span> = <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">controller</span>.<span style="color:#a6e22e">dependencyGraphBuilder</span>.<span style="color:#a6e22e">uidToNode</span>.<span style="color:#a6e22e">ToGonumGraph</span>()
	}

	<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dot</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">graph</span>, <span style="color:#e6db74">&#34;full&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#e6db74">&#34;  &#34;</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Error</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusInternalServerError</span>)
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;Content-Type&#34;</span>, <span style="color:#e6db74">&#34;text/vnd.graphviz&#34;</span>)
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Header</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;X-Content-Type-Options&#34;</span>, <span style="color:#e6db74">&#34;nosniff&#34;</span>)
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">data</span>)
	<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">WriteHeader</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusOK</span>)
}
</code></pre></div><p>使用该服务的方法如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s">curl http<span style="color:#f92672">://</span><span style="color:#ae81ff">192.168.199.100</span><span style="color:#f92672">:</span><span style="color:#ae81ff">10252</span><span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>controllers<span style="color:#f92672">/</span>garbagecollector<span style="color:#f92672">/</span>graph  <span style="color:#f92672">&gt;</span> tmp.dot

curl http<span style="color:#f92672">://</span><span style="color:#ae81ff">192.168.199.100</span><span style="color:#f92672">:</span><span style="color:#ae81ff">10252</span><span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>controllers<span style="color:#f92672">/</span>garbagecollector<span style="color:#f92672">/</span>graph<span style="color:#f92672">?</span>uid<span style="color:#f92672">=</span>f9555d53<span style="color:#ae81ff">-2</span>b5f<span style="color:#ae81ff">-4702-9717-54</span>a313ed4fe8 <span style="color:#f92672">&gt;</span> tmp.dot

<span style="color:#f92672">//</span> 生成 svg 文件
<span style="color:#f92672">$</span> dot <span style="color:#f92672">-</span>Tsvg <span style="color:#f92672">-</span>o graph.svg tmp.dot

<span style="color:#f92672">//</span> 然后在浏览器中打开 svg 文件
</code></pre></div><p>依赖关系如下图所示（点击图片查看更多）：</p>
<p>
  <a href="/kubernetes/kube-apiserver/gc/graph.svg">
  <img src="/kubernetes/kube-apiserver/gc/tmp.jpg" alt="tmp.jpg" /></a></p>
<h2 id="24-总结">
  2.4 总结
  <a class="anchor" href="#24-%e6%80%bb%e7%bb%93">#</a>
</h2>
<p><code>GarbageCollectorController</code> 是一种典型的生产者消费者模型，所有 deletableResources 的 informer 都是生产者，每种资源的 informer 监听到变化后都会将对应的事件 push 到 <code>graphChanges</code> 中，<code>graphChanges</code> 是 <code>GraphBuilder</code> 对象中的一个数据结构，<code>GraphBuilder</code> 会启动另外的 goroutine 对 graphChanges 中的事件进行分类并放在其 <code>attemptToDelete</code> 和 <code>attemptToOrphan</code> 两个队列中，garbageCollector 会启动多个 goroutine 对 <code>attemptToDelete</code> 和 <code>attemptToOrphan</code> 两个队列中的事件进行处理，处理的结果就是回收一些需要被删除的对象。最后，再用一个流程图总结一下 <code>GarbageCollectorController</code> 的主要流程：


<p class="mermaid">
graph LR
a[mirrors] -->|produce| b(graphChanges)
b --> c(processGraphChanges)
c --> d(attemptToDelete)
c --> e(attemptToOrphan)
d -->|consume| f[AttemptToDeleteWorker]
e -->|consume| g[AttemptToOrphanWorker]
</p>
</p>
<h1 id="3-参考资料">
  3. 参考资料
  <a class="anchor" href="#3-%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">#</a>
</h1>
<ul>
<li>
  <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/garbage-collection">垃圾收集</a></li>
<li>
  <a href="https://cloud.tencent.com/developer/article/1562130">garbage collector controller 源码分析</a></li>
<li>
  <a href="http://yangxikun.github.io/kubernetes/2020/03/17/kubernetes-delete-obj-and-garbage-collector-controller.html">Kubernetes API 资源对象的删除和 GarbageCollector Controller</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">



  <div><a class="flex align-center" href="https://github.com/howieyuen/howieyuen.github.io/commit/4359738ab58885be0fcb4ff5f079eca7c70c9fee" title='Last modified by howieyuen | January 6, 2021' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>January 6, 2021</span>
    </a>
  </div>



</div>

 
        
      </footer>

      
  
  <div class="book-comments">



  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script>
    let splits = location.pathname.split("/")
    const gitalk = new Gitalk({
      clientID: '25d476132e0758875147',
      clientSecret: '9648a660ceabeb1a20a6354a3c131481724f62db',
      repo: 'howieyuen.github.io',
      owner: 'howieyuen',
      admin: ['howieyuen'],
      id: splits[splits.length-1], 
      distractionFreeMode: false 
    });
    (function() {
      if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
        document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
        return;
      }
      gitalk.render('gitalk-container');
    })();
  </script>
</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#1-序言">1. 序言</a></li>
    <li><a href="#2-源码解析">2. 源码解析</a>
      <ul>
        <li><a href="#21-startgarbagecollectorcontroller">2.1 startGarbageCollectorController()</a>
          <ul>
            <li><a href="#211-garbagecollectorrun">2.1.1 garbageCollector.Run()</a></li>
            <li><a href="#212-gcrunattempttodeleteworker">2.1.2 gc.runAttemptToDeleteWorker()</a></li>
            <li><a href="#213-gcrunattempttoorphanworker">2.1.3 gc.runAttemptToOrphanWorker()</a></li>
            <li><a href="#214-小结">2.1.4 小结</a></li>
          </ul>
        </li>
        <li><a href="#22-garbagecollectorsync">2.2 garbageCollector.Sync()</a>
          <ul>
            <li><a href="#221-getdeletableresources">2.2.1 GetDeletableResources()</a></li>
            <li><a href="#222-gcresyncmonitors">2.2.2 gc.resyncMonitors()</a></li>
          </ul>
        </li>
        <li><a href="#23-garbagecollectornewdebughandler">2.3 garbagecollector.NewDebugHandler()</a></li>
        <li><a href="#24-总结">2.4 总结</a></li>
      </ul>
    </li>
    <li><a href="#3-参考资料">3. 参考资料</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












