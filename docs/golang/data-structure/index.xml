<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on 袁昊的学习笔记</title>
    <link>https://howieyuen.github.io/docs/golang/data-structure/</link>
    <description>Recent content in 数据结构 on 袁昊的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://howieyuen.github.io/docs/golang/data-structure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>chan</title>
      <link>https://howieyuen.github.io/docs/golang/data-structure/chan/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://howieyuen.github.io/docs/golang/data-structure/chan/</guid>
      <description>1. 引言 #  Go 语言中最常见的、也是经常被人提及的设计模式就是 —— 不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。
先入先出
目前的 Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：
 先从 Channel 读取数据的 Goroutine 会先接收到数据； 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；  2. 数据结构 #  type hchan struct { 	qcount uint // 当前队列中剩余元素个数 	dataqsiz uint // 环形队列长度，即可以存放的元素个数 	buf unsafe.Pointer // 环形队列指针 	elemsize uint16 // 每个元素的大小 	closed uint32 // 标识关闭状态 	elemtype *_type // 元素类型 	sendx uint // 发送操作处理到的位置 	recvx uint // 接收操作处理到的位置 	recvq waitq // 等待读消息的 goroutine 队列 	sendq waitq // 等待写消息的 goroutine 队列 	lock mutex // 互斥锁，chan 不允许并发读写 } 从数据结构可以看出 channel 由队列、类型信息、goroutine 等待队列组成，下面分别说明其原理。</description>
    </item>
    
    <item>
      <title>map</title>
      <link>https://howieyuen.github.io/docs/golang/data-structure/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://howieyuen.github.io/docs/golang/data-structure/map/</guid>
      <description>1. 引言 #  粗略的讲，Go 语言中 map 采用的是哈希查找表， 由一个 key 通过哈希函数得到哈希值， 64 位系统中就生成一个 64 bit 的哈希值， 由这个哈希值将 key 对应到不同的桶（bucket）中， 当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。
1.1 hash 函数 #  首先要知道的就是 map 中哈希函数的作用，go 中 map 使用 hash 作查找， 就是将 key 作哈希运算，得到一个哈希值，根据哈希值确定 key-value 落在哪个 bucket 的哪个 cell。 golang 使用的 hash 算法和 CPU 有关，如果 CPU 支持 aes，那么使用 aes hash，否则使用 memhash。
1.2 数据结构 #  hmap 可以理解为 header of map 的缩写，即 map 数据结构的入口。
type hmap struct { 	// map 中的元素个数，必须放在 struct 的第一个位置，因为 内置的 len 函数会从这里读取 	count int 	// map 状态标识，比如是否在被写或者迁移等，因为 map 不是线程安全的所以操作时需要判断 flags 	flags uint8 	// log_2 of buckets （最多可以放 loadFactor * 2^B 个元素即 6.</description>
    </item>
    
    <item>
      <title>slice</title>
      <link>https://howieyuen.github.io/docs/golang/data-structure/slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://howieyuen.github.io/docs/golang/data-structure/slice/</guid>
      <description>1. 数据结构 #  type slice struct {  array unsafe.Pointer  len int  cap int }  slice 的底层数据结构中的 array 是一个指针，指向的是一个 Array len 代表这个 slice 的元素个数 cap 表示 slice 指向的底层数组容量  对 slice 的赋值，以值作为函数参数时，只拷贝 1 个指针和 2 个 int 值。
2. 操作 #  2.1 创建 #   var []T 或 []T{} func make([]T,len,cap) []T  2.2 nil 切片和空切片 #   nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil.</description>
    </item>
    
  </channel>
</rss>
